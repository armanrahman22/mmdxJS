<!DOCTYPE HTML>
<html>
<head>
    <!-- tracking.js -->
    <script src="https://dl.dropboxusercontent.com/s/ctgjvud6im9mwmx/tracking-min.js"></script>

    <!-- functions to get test images in base 64-->
    <script type="text/javascript" src="getImage64.js"></script>

    <script type="text/javascript" src="utils.js"></script>
    <script type="text/javascript" src="helpers.js"></script>

</head>
<body>
<div id = "container">
    <canvas id="canvas"></canvas>

    <p> Fast marker detection using tracking.js, option 2 </p>
    <button type="button" onclick = "detectRectangle()"> Detect rectange </button>
    <button type="button" onclick = "crop()"> Crop </button>
    <button type="button" onclick = "rotate(corners[0],corners[1],corners[2],corners[3])"> Rotate </button>
    <button type="button" onclick = "removeMarkers()"> Remove markers </button>

</div>
<script>
    // file address: https://dl.dropboxusercontent.com/s/94xx26gfjrymr09/index.html

    // Test images hosted on Dropbox
    // var mmdx_image_normal = "https://dl.dropboxusercontent.com/s/qlf5rw12j6jz6mn/25c.png";
    // var mmdx_image_tilted_left = "https://dl.dropboxusercontent.com/s/qma3hkf1q3iuaim/Mmdx_tilted_left.jpg";
    // var mmdx_image_tilted_right = "https://dl.dropboxusercontent.com/s/t0819dq8xu1o4hh/mmdx_tilted.jpg?dl=0";


    var canvas = document.getElementById('canvas');
    var context = canvas.getContext('2d');
    var imageObj = new Image();
    var imageHeight, imageWidth;
    var imageData, pixels;

    //values for identifying what is red
    var redMax = 255; //need to check this values again (display dependancy)!!!
    var redMin = 180;
    var blueMax = 85;
    var greenMax = 85;

    //variables for the tracker.js
    var tracked_rect;
    var rotated = false;
    var corners = [];
    


    //Test images in base64
    var mmdx_image_normal = getTestImageNormal();
    var mmdx_image_tilted_right = getTestImageRotatedRight();
    var mmdx_image_tilted_left = getTestImageRotatedLeft();

    //Actual image we are using
    var mmdx_image = mmdx_image_tilted_left;


    imageObj.src = mmdx_image;
    imageObj.crossOrigin = "anonymous"; //just in case


    //draw image to canvas
    imageObj.onload = function() {
        imageHeight = imageObj.height;
        imageWidth = imageObj.width;
        canvas.height = imageHeight;
        canvas.width = imageWidth;
        context.drawImage(imageObj,0, 0);
    };


    //Register color tracking.js uses to identify markers
    tracking.ColorTracker.registerColor('marker', function(r, g, b) {
        if (isRedRGB(r,g,b)) {
            return true;
        }
        return false;
    });


    /**
    
    DETECTION:

    Uses tracking.js to find markers (color details are specified above)
    Finds a rectangle around a detected object 
         (tracker returns "rect" object {x: value, y:value, height:value, width:value, color:value})
    If not rotated, will draw the abovementioned rectange and use its corners
    If rotated, find the intersection of the actual rectange with the abovemention rectangle
    and assigns corners correctly
    */
       
    var detectRectangle = function(){

        imageData = context.getImageData(0,0,imageWidth, imageHeight);
        pixels = imageData.data;
        console.log("Start Detecting");


        var tracker = new tracking.ColorTracker(['marker']);
        tracker.on('track', function(event) {
            event.data.forEach(function(rect) {
                console.log("track");
                console.log(rect);
                tracked_rect = rect;

                checkIfRotated();

                if (rotated){
                    findCorners();
                }
                else{
                    drawStraightRectange(rect.x, rect.y, rect.width, rect.height); //corners are left as they are
                }
            });
        });
        tracking.track('#canvas', tracker); //start tracking

    }

    /*
    Moves along the detected rectangle, if the majority of the points are red, assumes
    tracker found a correct rectangle
    */
    var checkIfRotated = function(){
        var threshhold = .1;  //NEED TO ADJUST/TEST
        var x = tracked_rect.x;
        var y = tracked_rect.y;
        var w = tracked_rect.width;
        var h = tracked_rect.height;
        var numPoints = 2*(w+h);
        var countRed = 0;
        //move along the top edge
        for (var i = 0; i<w; i++){
            var px = getPixelRGB(pixels, x+i, y, imageWidth, imageWidth);
            if (isRed(px)){
                countRed++
            }
        }
        //bottom edge
        for (var i = 0; i<w; i++){
            var px = getPixelRGB(pixels, x+i, y+h, imageWidth, imageWidth);
            if (isRed(px)){
                countRed++
            }
        }

        //left edge
        for (var i = 0; i<h; i++){
            var px = getPixelRGB(pixels, x, y+i, imageWidth, imageWidth);
            if (isRed(px)){
                countRed++
            }
        }
        //right edge
        for (var i = 0; i<h; i++){
            var px = getPixelRGB(pixels, x+w, y+i, imageWidth, imageWidth);
            if (isRed(px)){
                countRed++
            }
        }
        if (countRed/numPoints < threshhold){
            console.log("Rotated");
            rotated = true;
            return true;
        }
        else{
            console.log("Not Rotated");
            rotated = false;
            return false;
        }
    }

    /*
    If checkIfRotated returns true, finds the corners of the rotated markers
    */
    var findCorners = function(){
        var x = tracked_rect.x;
        var y = tracked_rect.y;
        var w = tracked_rect.width;
        var h = tracked_rect.height;
        var c1, c2, c3, c4; //corners
        
        //check possible combinations:

        var inc = -1;

        // walk along the top rect edge (and lines right below), find the first points where 
        // the detected rectange intersects the marker (first red point)
        while (!c1){
            inc++;
            for (var i = 0; i < w; i++){
                var px = getPixelRGB(pixels, x+i, y+inc, imageWidth, imageWidth);
                if (isRed(px)){
                    c1 = [x+i, y];
                    console.log("C1");
                    console.log(c1);
                    break;
                }
            }
        }
        //same for the bottom rect egde
        inc = -1;
        while (!c2){
            inc++;
            for (var i = 0; i < w; i++){
                var px = getPixelRGB(pixels, x+i, y+h-inc, imageWidth, imageWidth);
                if (isRed(px)){
                    c2 = [x+i, y+h];
                    console.log("C2");
                    console.log(c2);
                    break;
                }
            }
        }
        // left rect edge
        inc = -1;
        while (!c3){
            inc++;
            //leftline
            for (var i = 0; i < h; i++){
                var px = getPixelRGB(pixels, x+inc, y+i, imageWidth, imageWidth);
                if (isRed(px)){
                    c3 = [x, y+i];
                    console.log("C3");
                    console.log(c3);
                    break;
                }
            }
        }
        // right rect edge
        while (!c4){
            inc++;
            for (var i = 0; i < h; i++){
                var px = getPixelRGB(pixels, x+w-inc, y+i, imageWidth, imageWidth);
                if (isRed(px)){
                    c4 = [x+w, y+i];
                    console.log("C4");
                    console.log(c4);
                    break;
                }
            }
        }

        drawRotatedRectangle(c1,c2,c3,c4);
        corners = [c1,c2,c3,c4];

    }

    /**
    Simply draws a rectange found by tracker
    */
    var drawStraightRectange = function(x, y, w, h) {
        context.beginPath();
        context.moveTo(x,y);
        context.lineTo(x+w, y);
        context.stroke();

        context.moveTo(x+w, y);
        context.lineTo(x+w, y+h);
        context.stroke();

        context.moveTo(x+w, y+h);
        context.lineTo(x, y+h);
        context.stroke();

        context.moveTo(x, y+h);
        context.lineTo(x, y);
        context.stroke();
        corners = [[x,y],[x+w, y+h], [x+w,y], [x, y+h]];

    }

    /*
    Draws a figure according the corners found in findCorners()
    */
    var drawRotatedRectangle = function(c1,c2,c3,c4) {
        console.log("drawRotatedRectangle");
        console.log(c1);
        context.beginPath();
        context.moveTo(c1[0],c1[1]);
        context.lineTo(c3[0],c3[1]);
        context.lineTo(c2[0],c2[1]);
        context.lineTo(c4[0],c4[1]);
        context.lineTo(c1[0],c1[1]);
        context.closePath();
        context.stroke();
    }


    /*
    Rotates the image based on the angle between the top line of the rect (from tracker)
    and new rotated rect (whose corners are found in findCorners())
    */
    var rotate = function (c1,c2,c3,c4){
        if (!rotated){
            alert("no need to rotate");
            return;
        }
        //rotate 10% more, because we sometimes overshoot
        var padding = .1; //CHECK/TEST

        //save image data so we can modify canvas
        var imageURL = canvas.toDataURL();
        var image = new Image();
        image.src = imageURL;

        console.log("rotating");
        console.log(c1[1]);
        console.log(c3[1]);
        //find upper left corner
        var uc = findUpperCorner(c1,c2,c3,c4);
        console.log("UPPER CORNER");
        console.log(uc);

        var side = findHighestSideCorner(c1,c2,c3,c4);
        console.log("SIDE");
        console.log(side);

        // B = uc, A = uc with the same y but different x, C = side
        var A = {"x": uc[0]+Math.round(tracked_rect.width/2), "y":uc[1]};
        var B = {"x":uc[0], "y": uc[1]};
        var C = {"x": side[0], "y":side[1]};
        var angle = findAngle(A,B,C);
        console.log("angle");
        console.log(angle);
        //find the center to rotate about
        var center = [Math.round(tracked_rect.x+tracked_rect.width/2), Math.round(tracked_rect.y+tracked_rect.height/2)];
        console.log("center");
        console.log(center);
        //context.clearRect(0,0,canvas.width,canvas.height);
        context.save();
        context.translate(center[0], center[1]);
        // ccw
        if (side[0]>uc[0]){
            console.log("CCW");
            context.rotate(-1*angle*(1+padding));

        }//cw
        else{
            console.log("CW");
            context.rotate((Math.PI-angle)*(1+padding));
        }
        context.translate(-1*center[0], -1*center[1]);
        context.drawImage(image,0, 0);
        context.restore();
        rotated = false;

    }

    /*
    Crops the image by its markers (either rect from tracker or adjusted corners)
    Assumes corners are known
    */
    var crop = function(){
        var c1 = corners[0];
        var c2 = corners[1];
        var c3 = corners[2];
        var c4 = corners[3];

        // Create a canvas that we will use as a mask
        var maskCanvas = document.createElement('canvas');
        // Ensure same dimensions
        maskCanvas.width = canvas.width;
        maskCanvas.height = canvas.height;
        var maskCtx = maskCanvas.getContext('2d');
        // This color is the one of the filled shape
        maskCtx.fillStyle = "white";
        // Fill the mask
        maskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);
        // Set xor operation
        maskCtx.globalCompositeOperation = 'xor';
        // Draw the shape you want to take out
        maskCtx.beginPath();
        maskCtx.moveTo(c1[0],c1[1]);
        maskCtx.lineTo(c3[0],c3[1]);
        maskCtx.lineTo(c2[0],c2[1]);
        maskCtx.lineTo(c4[0],c4[1]);
        maskCtx.lineTo(c1[0],c1[1]);
        maskCtx.closePath();
        maskCtx.fill();
        context.drawImage(maskCanvas, 0, 0);
        context.save();
    }

    /*
    Removes red markers, assumes the image is properly oriented 
    */
    var removeMarkers = function(){
        var padding = 10;
        console.log("removing");
        var leftEdge, rightEdge, upperEdge, lowerEdge;
        var w = canvas.width;
        var h = canvas.height;
        imageData = context.getImageData(0,0,w, h);
        pixels = imageData.data;
        var y = 0;
        //look for beginning of the top edge
        while(!(isRed(getPixelRGB(pixels, Math.round(w/2),y, w, h)))){
            y++;
        }
        //end of the top edge
        while (isRed(getPixelRGB(pixels, Math.round(w/2),y, w, h))) {
            y++;
        }
        upperEdge = y-1;

        //look for beginning of the bottom edge
        y = h;
        while(!(isRed(getPixelRGB(pixels, Math.round(w/2),y, w, h)))){
            y--;
        }
        //end of the bottom edge
        while (isRed(getPixelRGB(pixels, Math.round(w/2),y, w, h))) {
            y--;
        }
        lowerEdge = y+1;

        //look for beginning of the left edge
        var x = 0;
        while(!(isRed(getPixelRGB(pixels, x, Math.round(h/2), w, h)))){
            x++;
        }
        //end of the right edge
        while (isRed(getPixelRGB(pixels, x,Math.round(h/2), w, h))) {
            x++;
        }
        leftEdge = x+1;

        var x = w;
        while(!(isRed(getPixelRGB(pixels, x, Math.round(h/2), w, h)))){
            x--;
        }
        //end of the right edge
        while (isRed(getPixelRGB(pixels, x,Math.round(h/2), w, h))) {
            x--;
        }
        rightEdge = x-1;

        for (var x = 0; x < w; x++){
            for (var y = 0; y < h; y++){
                var px = getPixelRGB(pixels, x, y, w,h);

                if (!(x >= leftEdge+padding && x <= rightEdge-padding && y >= upperEdge+padding && y <= lowerEdge-padding)){
                    var position = getPixelPosition(x, y, w,h);
                    //set everything outside of the image to white
                    pixels[position] = 255;
                    pixels[position+1] = 255;
                    pixels[position+2] = 255;
                }

            }
        }
        context.putImageData(imageData,0,0);


    }


    document.onmousedown = printCoordsAndRGB;

    function printCoordsAndRGB(e){
        var x = e.pageX;
        var y = e.pageY;
        var coords = "Mouse x = "+x+", mouse y = "+y;
        console.log(coords);
        if (pixels){
            console.log(getPixelRGB(pixels, x,y, imageWidth,imageHeight));
        }
    }

</script>
</body>
</html>    