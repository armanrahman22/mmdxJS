<!DOCTYPE HTML>
<html>
<head>
    <!-- tracking.js -->
    <script src="https://dl.dropboxusercontent.com/s/ctgjvud6im9mwmx/tracking-min.js"></script>

    <!-- functions to get test images in base 64-->
    <script type="text/javascript" src="getImage64.js"></script>

    <script type="text/javascript" src="utils.js"></script>
    <script type="text/javascript" src="helpers.js"></script>
    <script type="text/javascript" src="data_structures.js"></script>

    <script type="text/javascript" src="cornerdetect.js"></script>

</head>
<body>
<div id = "container">
    <canvas id="canvas"></canvas>

    <p> Fast marker detection using tracking.js and Harris operator, option 2 </p>
    <button type="button" onclick = "detect()"> Detect rectange </button>
    <button type="button" onclick = "crop()"> Crop </button>
    <button type="button" onclick = "rotate()"> Rotate </button>
    <button type="button" onclick = "removeMarkers()"> Remove markers </button>

</div>
<script>
    // file address: https://dl.dropboxusercontent.com/s/94xx26gfjrymr09/index.html

    // Test images hosted on Dropbox
    // var mmdx_image_normal = "https://dl.dropboxusercontent.com/s/qlf5rw12j6jz6mn/25c.png";
    // var mmdx_image_tilted_left = "https://dl.dropboxusercontent.com/s/qma3hkf1q3iuaim/Mmdx_tilted_left.jpg";
    // var mmdx_image_tilted_right = "https://dl.dropboxusercontent.com/s/t0819dq8xu1o4hh/mmdx_tilted.jpg?dl=0";


    var canvas = document.getElementById('canvas');
    var context = canvas.getContext('2d');
    var imageObj = new Image();
    var imageHeight, imageWidth;
    var imageData, pixels;

    //values for identifying what is red
    var redMax = 255; //need to check this values again (display dependancy)!!!
    var redMin = 180;
    var blueMax = 85;
    var greenMax = 85;

    //variables for the tracker.js
    var tracked_rect;
    var markerRectangle;
    


    //Test images in base64
    var mmdx_image_normal = getTestImageNormal();
    var mmdx_image_tilted_right = getTestImageRotatedRight();
    var mmdx_image_tilted_left = getTestImageRotatedLeft();

    //Actual image we are using
    var mmdx_image = mmdx_image_tilted_left;


    imageObj.src = mmdx_image;
    imageObj.crossOrigin = "anonymous"; //just in case


    //draw image to canvas
    imageObj.onload = function() {
        imageHeight = imageObj.height;
        imageWidth = imageObj.width;
        canvas.height = imageHeight;
        canvas.width = imageWidth;
        context.drawImage(imageObj,0, 0);
    };


    //Register color tracking.js uses to identify markers
    tracking.ColorTracker.registerColor('marker', function(r, g, b) {
        if (isRedRGB(r,g,b)) {
            return true;
        }
        return false;
    });


    // PURE DEMO FUNCTION (to show how good cornderdetect.js is, does nothing for image processing)
    var cornerDetectionDemo = function(){
        // parameters for Harris corner detection
        // blockSize: Neighborhood size (3×3 or 5×5)
        // k: Harris detector free parameter (recommends 0.04 ~ 0.15)
        // qualityLevel: Parameter characterizing the minimal accepted quality of image corners
        var params = { blockSize: 3, k: 0.04, qualityLevel: 0.001 };
        // img: ImageData object
        // returns Array of detected corners
        var img = context.getImageData(0,0,imageWidth, imageHeight);
        pixels = img.data;
        var corners = CornerDetector.detect(img, CornerDetector.HARRIS, params);
        var nonzero = [];
        for (var i = 0; i< corners.length; i++){
            if (corners[i]!=0){
                nonzero.push(i);
            }
        }
        console.log(nonzero);
        for (var j=0; j< nonzero.length; j++){
            var coords = getCoordsFromPixelOffset(nonzero[j], imageWidth, imageHeight);
            context.beginPath();
            context.arc(coords[0], coords[1], 3, 0, 2 * Math.PI, false);
            context.lineWidth = 1;
            context.strokeStyle = 'yellow';
            context.stroke();
        }
        return corners;
    }

    var detectCorners = function(){
        // parameters for Harris corner detection
        // blockSize: Neighborhood size (3×3 or 5×5)
        // k: Harris detector free parameter (recommends 0.04 ~ 0.15)
        // qualityLevel: Parameter characterizing the minimal accepted quality of image corners
        var params = {blockSize: 5, k: 0.04, qualityLevel: 0.01 };
        // img: ImageData object
        // returns Array of detected corners
        var img = context.getImageData(0,0,imageWidth, imageHeight);
        pixels = img.data;
        var corners = CornerDetector.detect(img, CornerDetector.HARRIS, params);//all corners
        var nonzero = [];
        for (var i = 0; i< corners.length; i++){
            if (corners[i]!=0){
                nonzero.push(i);
            }
        }
        //filter by color
        var redCorners = [];
        for (var j=0; j< nonzero.length; j++){
            var coords = getCoordsFromPixelOffset(nonzero[j], imageWidth, imageHeight);
            if (isAreaRed(coords[0],coords[1], 2, pixels, imageWidth, imageHeight)){
                redCorners.push(new Point(coords[0], coords[1]));
                //visually show detected points
                context.beginPath();
                context.arc(coords[0], coords[1], 5, 0, 2 * Math.PI);
                context.lineWidth = 2;
                context.strokeStyle = 'yellow';
                context.stroke();
            }
            
        }

        return redCorners;
    }
    /**
    
    DETECTION:

    Uses tracking.js to find markers (color details are specified above)
    Finds a rectangle around a detected object 
         (tracker returns "rect" object {x: value, y:value, height:value, width:value, color:value})
    If not rotated, will draw the abovementioned rectange and use its corners
    If rotated, find the intersection of the actual rectange with the abovemention rectangle
    and assigns corners correctly
    */
    
    var detect = function(){

        imageData = context.getImageData(0,0,imageWidth, imageHeight);
        pixels = imageData.data;
        console.log("Start Detecting");


        var tracker = new tracking.ColorTracker(['marker']);
        tracker.on('track', function(event) {
            event.data.forEach(function(rect) {
                tracked_rect = rect;
                var x = rect.x;
                var y = rect.y;
                var w = rect.width;
                var h = rect.height;
                //corners might change
                var corners = [new Point(x,y),new Point(x+w, y+h), new Point(x+w,y), new Point(x, y+h)];
                

                var rotated = checkIfRotated();
                markerRectangle = new Rectangle(corners, rotated);

                if (markerRectangle.isRotated()){
                    findCorners();
                }
                drawRectangle(markerRectangle.getCorners());
            });
        });
        tracking.track('#canvas', tracker); //start tracking

    }

    /*
    Moves along the detected rectangle, if the majority of the points are red, assumes
    tracker found a correct rectangle
    */
    var checkIfRotated = function(){
        var threshhold = .1;  //NEED TO ADJUST/TEST
        var x = tracked_rect.x;
        var y = tracked_rect.y;
        var w = tracked_rect.width;
        var h = tracked_rect.height;
        var numPoints = 2*(w+h);
        var countRed = 0;
        //move along the top edge
        for (var i = 0; i<w; i++){
            var px = getPixelRGB(pixels, x+i, y, imageWidth, imageWidth);
            if (isRed(px)){
                countRed++
            }
        }
        //bottom edge
        for (var i = 0; i<w; i++){
            var px = getPixelRGB(pixels, x+i, y+h, imageWidth, imageWidth);
            if (isRed(px)){
                countRed++
            }
        }

        //left edge
        for (var i = 0; i<h; i++){
            var px = getPixelRGB(pixels, x, y+i, imageWidth, imageWidth);
            if (isRed(px)){
                countRed++
            }
        }
        //right edge
        for (var i = 0; i<h; i++){
            var px = getPixelRGB(pixels, x+w, y+i, imageWidth, imageWidth);
            if (isRed(px)){
                countRed++
            }
        }
        if (countRed/numPoints < threshhold){
            console.log("Rotated");
            return true;
        }
        else{
            console.log("Not Rotated");
            return false;
        }
    }

    /*
    If checkIfRotated returns true, finds the corners of the rotated markers
    */
    var findCorners = function(){
        var x = tracked_rect.x;
        var y = tracked_rect.y;
        var w = tracked_rect.width;
        var h = tracked_rect.height;
        var c1, c2, c3, c4; //corners
        
        //check possible combinations:

        var inc = -1;

        // walk along the top rect edge (and lines right below), find the first points where 
        // the detected rectange intersects the marker (first red point)
        while (!c1){
            inc++;
            for (var i = 0; i < w; i++){
                var px = getPixelRGB(pixels, x+i, y+inc, imageWidth, imageWidth);
                if (isRed(px)){
                    c1 = new Point(x+i, y);
                    console.log("C1");
                    console.log(c1);
                    break;
                }
            }
        }
        //same for the bottom rect egde
        inc = -1;
        while (!c2){
            inc++;
            for (var i = 0; i < w; i++){
                var px = getPixelRGB(pixels, x+i, y+h-inc, imageWidth, imageWidth);
                if (isRed(px)){
                    c2 = new Point(x+i, y+h);
                    console.log("C2");
                    console.log(c2);
                    break;
                }
            }
        }
        // left rect edge
        inc = -1;
        while (!c3){
            inc++;
            //leftline
            for (var i = 0; i < h; i++){
                var px = getPixelRGB(pixels, x+inc, y+i, imageWidth, imageWidth);
                if (isRed(px)){
                    c3 = new Point(x, y+i);
                    console.log("C3");
                    console.log(c3);
                    break;
                }
            }
        }
        // right rect edge
        while (!c4){
            inc++;
            for (var i = 0; i < h; i++){
                var px = getPixelRGB(pixels, x+w-inc, y+i, imageWidth, imageWidth);
                if (isRed(px)){
                    c4 = new Point(x+w, y+i);
                    console.log("C4");
                    console.log(c4);
                    break;
                }
            }
        }
        //adjust corners according to the Harris operator
        var cornersHarris = detectCorners();
        //drawRotatedRectangle(c1,c2,c3,c4);
        var corners = [c1,c2,c3,c4];
        for (var i = 0; i< 4; i++){
            var closest = findClosest(corners[i], cornersHarris, imageWidth*0.02);
            if (closest){
                corners[i] = closest;
            }     

        }
        markerRectangle.setCorners(corners);

    }

    var drawRectangle = function(points){
        var c1 = points[0];
        var c2 = points[1];
        var c3 = points[2];
        var c4 = points[3];
        context.beginPath();
        context.beginPath();
        context.moveTo(c1.x,c1.y);
        context.lineTo(c3.x,c3.y);
        context.lineTo(c2.x,c2.y);
        context.lineTo(c4.x,c4.y);
        context.lineTo(c1.x,c1.y);
        context.closePath();
        context.stroke();
    }

    /*
    Rotates the image based on the angle between the top line of the rect (from tracker)
    and new rotated rect (whose corners are found in findCorners())
    */
    var rotate = function (){
        if (!markerRectangle.isRotated()){
            alert("no need to rotate");
            return;
        }

        var c1 = markerRectangle.getCorners()[0];
        var c2 = markerRectangle.getCorners()[1];
        var c3 = markerRectangle.getCorners()[2];
        var c4 = markerRectangle.getCorners()[3];
        
        //save image data so we can modify canvas
        var imageURL = canvas.toDataURL();
        var image = new Image();
        image.src = imageURL;

        var angle = markerRectangle.findAngleOfRotation();

        //find the center to rotate about
        var center = new Point(Math.round(tracked_rect.x+tracked_rect.width/2), Math.round(tracked_rect.y+tracked_rect.height/2));
        context.translate(1*center.x, 1*center.y);
        
        //context.clearRect(0,0,canvas.width,canvas.height);
        context.save();
        context.rotate(angle.radians);
        context.translate(-1*center.x, -1*center.y);
        context.drawImage(image,0, 0);
        context.restore();
        rotated = false;

    }

    /*
    Crops the image by its markers (either rect from tracker or adjusted corners)
    Assumes corners are known
    */
    var crop = function(){
        var c1 = markerRectangle.getCorners()[0];
        var c2 = markerRectangle.getCorners()[1];
        var c3 = markerRectangle.getCorners()[2];
        var c4 = markerRectangle.getCorners()[3];

        // Create a canvas that we will use as a mask
        var maskCanvas = document.createElement('canvas');
        // Ensure same dimensions
        maskCanvas.width = canvas.width;
        maskCanvas.height = canvas.height;
        var maskCtx = maskCanvas.getContext('2d');
        // This color is the one of the filled shape
        maskCtx.fillStyle = "white";
        // Fill the mask
        maskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);
        // Set xor operation
        maskCtx.globalCompositeOperation = 'xor';
        // Draw the shape you want to take out
        maskCtx.beginPath();
        maskCtx.moveTo(c1.x,c1.y);
        maskCtx.lineTo(c3.x,c3.y);
        maskCtx.lineTo(c2.x,c2.y);
        maskCtx.lineTo(c4.x,c4.y);
        maskCtx.lineTo(c1.x,c1.y);
        maskCtx.closePath();
        maskCtx.fill();
        context.drawImage(maskCanvas, 0, 0);
        context.save();
    }

    /*
    Removes red markers, assumes the image is properly oriented 
    */
    var removeMarkers = function(){
        var padding = 10;
        console.log("removing");
        var leftEdge, rightEdge, upperEdge, lowerEdge;
        var w = canvas.width;
        var h = canvas.height;
        imageData = context.getImageData(0,0,w, h);
        pixels = imageData.data;
        var y = 0;
        //look for beginning of the top edge
        while(!(isRed(getPixelRGB(pixels, Math.round(w/2),y, w, h)))){
            y++;
        }
        //end of the top edge
        while (isRed(getPixelRGB(pixels, Math.round(w/2),y, w, h))) {
            y++;
        }
        upperEdge = y-1;

        //look for beginning of the bottom edge
        y = h;
        while(!(isRed(getPixelRGB(pixels, Math.round(w/2),y, w, h)))){
            y--;
        }
        //end of the bottom edge
        while (isRed(getPixelRGB(pixels, Math.round(w/2),y, w, h))) {
            y--;
        }
        lowerEdge = y+1;

        //look for beginning of the left edge
        var x = 0;
        while(!(isRed(getPixelRGB(pixels, x, Math.round(h/2), w, h)))){
            x++;
        }
        //end of the right edge
        while (isRed(getPixelRGB(pixels, x,Math.round(h/2), w, h))) {
            x++;
        }
        leftEdge = x+1;

        var x = w;
        while(!(isRed(getPixelRGB(pixels, x, Math.round(h/2), w, h)))){
            x--;
        }
        //end of the right edge
        while (isRed(getPixelRGB(pixels, x,Math.round(h/2), w, h))) {
            x--;
        }
        rightEdge = x-1;

        for (var x = 0; x < w; x++){
            for (var y = 0; y < h; y++){
                var px = getPixelRGB(pixels, x, y, w,h);

                if (!(x >= leftEdge+padding && x <= rightEdge-padding && y >= upperEdge+padding && y <= lowerEdge-padding)){
                    var position = getPixelPosition(x, y, w,h);
                    //set everything outside of the image to white
                    pixels[position] = 255;
                    pixels[position+1] = 255;
                    pixels[position+2] = 255;
                }

            }
        }
        context.putImageData(imageData,0,0);


    }


    document.onmousedown = printCoordsAndRGB;

    function printCoordsAndRGB(e){
        var x = e.pageX;
        var y = e.pageY;
        var coords = "Mouse x = "+x+", mouse y = "+y;
        console.log(coords);
        if (pixels){
            var px = getPixelRGB(pixels, x,y, imageWidth,imageHeight);
            console.log(px);
            console.log(rgbToHsl(px.r, px.g, px.b));
        }
    }

</script>
</body>
</html>    