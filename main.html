<!DOCTYPE HTML>
<html>
<head>
    <!-- Caman.js and tracking.js -->
    <script src="https://dl.dropboxusercontent.com/s/9h6ddirr60ie1mv/jquery.min.js"></script>
    <script src="https://dl.dropboxusercontent.com/s/ctgjvud6im9mwmx/tracking-min.js"></script>
    <script type="text/javascript" src="https://cdnjs.cloudflare.com/ajax/libs/camanjs/4.1.2/caman.full.js"></script>

</head>
<body>
<div id = "container">
    <canvas id="canvas"></canvas>

    <p> Fast marker detection using tracking.js, option 2 </p>
    <button type="button" onclick = "detectRectangle()"> Detect rectange </button>
    <button type="button" onclick = "crop()"> Crop </button>
    <button type="button" onclick = "rotate(corners[0],corners[1],corners[2],corners[3])"> Rotate </button>
    <button type="button" onclick = "removeMarkers()"> Remove markers </button>

</div>
<script>
    // file address: https://dl.dropboxusercontent.com/s/94xx26gfjrymr09/index.html
    var canvas = document.getElementById('canvas');
    var context = canvas.getContext('2d');
    var imageObj = new Image();
    var imageHeight, imageWidth;
    var imageData, pixels;
    var redMax = 255; //need to check this values again
    var redMin = 180;
    var blueMax = 85;
    var greenMax = 85;

    //vars for the tracker.js
    var tracked_rect;
    var rotated = false;
    var corners = [];
    // vars for handmade marker detection
    var markerPoints = [];
    var markerPointsChecked = [];

    var mmdx_image_normal = "https://dl.dropboxusercontent.com/s/qlf5rw12j6jz6mn/25c.png?dl=0";
    var mmdx_image_tilted_left = "https://dl.dropboxusercontent.com/s/qma3hkf1q3iuaim/Mmdx_tilted_left.jpg";
    var mmdx_image_tilted_right = "https://dl.dropboxusercontent.com/s/t0819dq8xu1o4hh/mmdx_tilted.jpg?dl=0";
    var mmdx_image = mmdx_image_tilted_right;
    //var imageAddress = 'https://dl.dropboxusercontent.com/s/57emsqhec1ostv0/i.png';
    imageObj.src = mmdx_image;
    imageObj.crossOrigin = "anonymous";

    imageObj.onload = function() {
        imageHeight = imageObj.height;
        imageWidth = imageObj.width;
        canvas.height = imageHeight;
        canvas.width = imageWidth;
        context.drawImage(imageObj,0, 0);
    };
    tracking.ColorTracker.registerColor('marker', function(r, g, b) {
        if (isRedRGB(r,g,b)) {
            return true;
        }
        return false;
    });

    tracking.ColorTracker.registerColor('non-marker', function(r, g, b) {
        if (!isRedRGB(r,g,b)) {
            return true;
        }
        return false;
    });


    //DETECTION using tracking.js
    var detectRectangle = function(){


        imageData = context.getImageData(0,0,imageWidth, imageHeight);
        pixels = imageData.data;
        console.log("Start Detecting");


        var tracker = new tracking.ColorTracker(['marker']);
        tracker.on('track', function(event) {
            event.data.forEach(function(rect) {
                console.log("track");
                console.log(rect);
                tracked_rect = rect;

                checkIfRotated();

                if (rotated){
                    findCorners();
                }
                else{
                    drawStraightRectange(rect.x, rect.y, rect.width, rect.height);
                }

            });
        });
        tracking.track('#canvas', tracker);

    }

    var checkIfRotated = function(){
        var threshhold = .1;
        var x = tracked_rect.x;
        var y = tracked_rect.y;
        var w = tracked_rect.width;
        var h = tracked_rect.height;
        var numPoints = 2*(w+h);
        var countRed = 0;
        for (var i = 0; i<w; i++){
            var px = getPixelRGB(pixels, x+i, y, imageWidth, imageWidth);
            if (isRed(px)){
                countRed++
            }
        }
        for (var i = 0; i<w; i++){
            var px = getPixelRGB(pixels, x+i, y+h, imageWidth, imageWidth);
            if (isRed(px)){
                countRed++
            }
        }
        for (var i = 0; i<h; i++){
            var px = getPixelRGB(pixels, x, y+i, imageWidth, imageWidth);
            if (isRed(px)){
                countRed++
            }
        }
        for (var i = 0; i<h; i++){
            var px = getPixelRGB(pixels, x+w, y+i, imageWidth, imageWidth);
            if (isRed(px)){
                countRed++
            }
        }
        console.log("count red");
        console.log(countRed);
        console.log("num points");
        console.log(numPoints);
        if (countRed/numPoints < threshhold){
            console.log("Rotated");
            rotated = true;
            return true;
        }
        else{
            console.log("Not Rotated");
            rotated = false;
            return false;
        }
    }
    var findCorners = function(){
        var x = tracked_rect.x;
        var y = tracked_rect.y;
        var w = tracked_rect.width;
        var h = tracked_rect.height;
        var c1, c2, c3, c4;
        //check possible combinations:
        var inc = -1;

        while (!c1){
            inc++;
            //upper line
            for (var i = 0; i < w; i++){
                var px = getPixelRGB(pixels, x+i, y+inc, imageWidth, imageWidth);
                if (isRed(px)){
                    c1 = [x+i, y];
                    console.log("C1");
                    console.log(c1);
                    break;
                }
            }
        }

        inc = -1;
        while (!c2){
            inc++;
            //lower line
            for (var i = 0; i < w; i++){
                var px = getPixelRGB(pixels, x+i, y+h-inc, imageWidth, imageWidth);
                if (isRed(px)){
                    c2 = [x+i, y+h];
                    console.log("C2");
                    console.log(c2);
                    break;
                }
            }
        }
        inc = -1;
        while (!c3){
            inc++;
            //leftline
            for (var i = 0; i < h; i++){
                var px = getPixelRGB(pixels, x+inc, y+i, imageWidth, imageWidth);
                if (isRed(px)){
                    c3 = [x, y+i];
                    console.log("C3");
                    console.log(c3);
                    break;
                }
            }
        }
        while (!c4){
            inc++;
            //right line
            for (var i = 0; i < h; i++){
                var px = getPixelRGB(pixels, x+w-inc, y+i, imageWidth, imageWidth);
                if (isRed(px)){
                    c4 = [x+w, y+i];
                    console.log("C4");
                    console.log(c4);
                    break;
                }
            }
        }

        drawRotatedRectangle(c1,c2,c3,c4);
        corners = [c1,c2,c3,c4];


    }


    var drawStraightRectange = function(x, y, w, h) {
        context.beginPath();
        context.moveTo(x,y);
        context.lineTo(x+w, y);
        context.stroke();

        context.moveTo(x+w, y);
        context.lineTo(x+w, y+h);
        context.stroke();

        context.moveTo(x+w, y+h);
        context.lineTo(x, y+h);
        context.stroke();

        context.moveTo(x, y+h);
        context.lineTo(x, y);
        context.stroke();
        corners = [[x,y],[x+w, y+h], [x+w,y], [x, y+h]];

    }

    var drawRotatedRectangle = function(c1,c2,c3,c4) {
        console.log("drawRotatedRectangle");
        console.log(c1);
        context.beginPath();
        context.moveTo(c1[0],c1[1]);
        context.lineTo(c3[0],c3[1]);
        context.lineTo(c2[0],c2[1]);
        context.lineTo(c4[0],c4[1]);
        context.lineTo(c1[0],c1[1]);
        context.closePath();
        context.stroke();
    }


    var rotate = function (c1,c2,c3,c4){
        if (!rotated){
            alert("no need to rotate");
            return;
        }
        //rotate 10% more
        var padding = .1;
        var croppedImageURL = canvas.toDataURL();
        var croppedImage = new Image();
        croppedImage.src = croppedImageURL;

        console.log("rotating");
        console.log(c1[1]);
        console.log(c3[1]);
        //find upper left corner
        var uc = findUpperCorner(c1,c2,c3,c4);
        console.log("UPPER CORNER");
        console.log(uc);

        var side = findHighestSideCorner(c1,c2,c3,c4);
        console.log("SIDE");
        console.log(side);

        // B = uc, A = uc with the same y but different x, C = side
        var A = {"x": uc[0]+Math.round(tracked_rect.width/2), "y":uc[1]};
        var B = {"x":uc[0], "y": uc[1]};
        var C = {"x": side[0], "y":side[1]};
        var angle = findAngle(A,B,C);
        console.log("angle");
        console.log(angle);
        var center = [Math.round(tracked_rect.x+tracked_rect.width/2), Math.round(tracked_rect.y+tracked_rect.height/2)];
        console.log("center");
        console.log(center);
        //context.clearRect(0,0,canvas.width,canvas.height);
        context.save();
        context.translate(center[0], center[1]);
        // ccw
        if (side[0]>uc[0]){
            console.log("CCW");
            context.rotate(-1*angle*(1+padding));

        }//cw
        else{
            console.log("CW");
            context.rotate((Math.PI-angle)*(1+padding));
        }
        context.translate(-1*center[0], -1*center[1]);
        context.drawImage(croppedImage,0, 0);
        context.restore();
        rotated = false;

    }

    var crop = function(){
        var c1 = corners[0];
        var c2 = corners[1];
        var c3 = corners[2];
        var c4 = corners[3];

        // Create a canvas that we will use as a mask
        var maskCanvas = document.createElement('canvas');
        // Ensure same dimensions
        maskCanvas.width = canvas.width;
        maskCanvas.height = canvas.height;
        var maskCtx = maskCanvas.getContext('2d');
        // This color is the one of the filled shape
        maskCtx.fillStyle = "white";
        // Fill the mask
        maskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);
        // Set xor operation
        maskCtx.globalCompositeOperation = 'xor';
        // Draw the shape you want to take out
        maskCtx.beginPath();
        maskCtx.moveTo(c1[0],c1[1]);
        maskCtx.lineTo(c3[0],c3[1]);
        maskCtx.lineTo(c2[0],c2[1]);
        maskCtx.lineTo(c4[0],c4[1]);
        maskCtx.lineTo(c1[0],c1[1]);
        maskCtx.closePath();
        maskCtx.fill();
        context.drawImage(maskCanvas, 0, 0);
        context.save();
    }

    var removeMarkers = function(){
        var padding = 10;
        console.log("removing");
        var leftEdge, rightEdge, upperEdge, lowerEdge;
        var w = canvas.width;
        var h = canvas.height;
        imageData = context.getImageData(0,0,w, h);
        pixels = imageData.data;
        var y = 0;
        //look for beginning of the edge
        while(!(isRed(getPixelRGB(pixels, Math.round(w/2),y, w, h)))){
            y++;
        }
        //end of the edge
        while (isRed(getPixelRGB(pixels, Math.round(w/2),y, w, h))) {
            y++;
        }
        upperEdge = y-1;
        //look for beginning of the edge
        y = h;
        while(!(isRed(getPixelRGB(pixels, Math.round(w/2),y, w, h)))){
            y--;
        }
        //end of the edge
        while (isRed(getPixelRGB(pixels, Math.round(w/2),y, w, h))) {
            y--;
        }
        lowerEdge = y+1;

        //look for beginning of the edge
        var x = 0;
        while(!(isRed(getPixelRGB(pixels, x, Math.round(h/2), w, h)))){
            x++;
        }
        //end of the edge
        while (isRed(getPixelRGB(pixels, x,Math.round(h/2), w, h))) {
            x++;
        }
        leftEdge = x+1;

        var x = w;
        while(!(isRed(getPixelRGB(pixels, x, Math.round(h/2), w, h)))){
            x--;
        }
        //end of the edge
        while (isRed(getPixelRGB(pixels, x,Math.round(h/2), w, h))) {
            x--;
        }
        rightEdge = x-1;

        console
        for (var x = 0; x < w; x++){
            for (var y = 0; y < h; y++){
                var px = getPixelRGB(pixels, x, y, w,h);

                if (!(x >= leftEdge+padding && x <= rightEdge-padding && y >= upperEdge+padding && y <= lowerEdge-padding)){
                    var position = getPixelPosition(x, y, w,h);
                    pixels[position] = 255;
                    pixels[position+1] = 255;
                    pixels[position+2] = 255;
                }

            }
        }
        context.putImageData(imageData,0,0);


    }



    // HELPERS
    var getPixelRGB = function(pixels, x,y, imageWidth, imageHeight){
        var red = pixels[y*imageWidth*4+x*4];
        var green = pixels[y*imageWidth*4+x*4+1];
        var blue = pixels[y*imageWidth*4+x*4+2];
        return {"r":red, "g":green, "b":blue}
    }


    function rgbToHsl(r, g, b) {
        r /= 255, g /= 255, b /= 255;
        var max = Math.max(r, g, b),
                min = Math.min(r, g, b);
        var h, s, l = (max + min) / 2;

        if (max == min) {
            h = s = 0; // achromatic
        } else {
            var d = max - min;
            s = l > 0.5 ? d / (2 - max - min) : d / (max + min);
            switch (max) {
                case r:
                    h = (g - b) / d + (g < b ? 6 : 0);
                    break;
                case g:
                    h = (b - r) / d + 2;
                    break;
                case b:
                    h = (r - g) / d + 4;
                    break;
            }
            h /= 6;
        }

        return ({
            h: h,
            s: s,
            l: l,
        });
    }

    function hslToRgb(h, s, l) {
        var r, g, b;

        if (s == 0) {
            r = g = b = l; // achromatic
        } else {
            function hue2rgb(p, q, t) {
                if (t < 0) t += 1;
                if (t > 1) t -= 1;
                if (t < 1 / 6) return p + (q - p) * 6 * t;
                if (t < 1 / 2) return q;
                if (t < 2 / 3) return p + (q - p) * (2 / 3 - t) * 6;
                return p;
            }

            var q = l < 0.5 ? l * (1 + s) : l + s - l * s;
            var p = 2 * l - q;
            r = hue2rgb(p, q, h + 1 / 3);
            g = hue2rgb(p, q, h);
            b = hue2rgb(p, q, h - 1 / 3);
        }

        return ({
            r: Math.round(r * 255),
            g: Math.round(g * 255),
            b: Math.round(b * 255),
        });
    }

    var  getPixelPosition = function(x, y, imageWidth, imageHeight){
        return y*imageWidth*4+x*4;
    }
    var isRed = function(px){
        var  hsl = rgbToHsl(px.r, px.g,px.b);
        var hue = hsl.h * 360;
        if (((hue<=360 && hue >=357) || (hue <=20)) && hsl.s > .7){
            return true
        }
        else{
            return false
        }
    };

    function isRedRGB(r,g,b){
        var  hsl = rgbToHsl(r, g, b);
        var hue = hsl.h * 360;
        if (((hue<=360 && hue >=357) || (hue <=20)) && hsl.s > .7){
            return true
        }
        else{
            return false
        }
    }


    function findUpperCorner(a,b,c,d){
        var y = [a[1], b[1], c[1], d[1]].minElement();
        if (a[1]==y){
            return a;
        }
        else if (b[1]==y){
            return b;
        }
        else if (c[1]==y){
            return c;
        }
        else if (d[1]==y){
            return d;
        }
        //should never get here
        else{
            alert("Error in findUpperCorner function");
        }
    }
    function findHighestSideCorner(a,b,c,d){
        var ys = [a[1], b[1], c[1], d[1]];

        ys.sort(function(a, b){return a-b});
        console.log("sort");
        console.log(ys);
        //second highest element
        var y = ys[1];
        if (a[1]==y){
            return a;
        }
        else if (b[1]==y){
            return b;
        }
        else if (c[1]==y){
            return c;
        }
        else if (d[1]==y){
            return d;
        }
        //should never get here
        else{
            alert("Error in findUpperCorner function");
        }
    }
    /*
     * Calculates the angle ABC (in radians)
     *
     * A first point
     * C second point
     * B center point
     */
    function findAngle(A,B,C) {
        var AB = Math.sqrt(Math.pow(B.x-A.x,2)+ Math.pow(B.y-A.y,2));
        var BC = Math.sqrt(Math.pow(B.x-C.x,2)+ Math.pow(B.y-C.y,2));
        var AC = Math.sqrt(Math.pow(C.x-A.x,2)+ Math.pow(C.y-A.y,2));
        return Math.acos((BC*BC+AB*AB-AC*AC)/(2*BC*AB));
    }
    function rotateCorner(angle, corner, center){
        var pointX = corner[0];
        var pointY = corner[1];
        var originX = center[0];
        var originY = center[1];
        var x = Math.cos(angle) * (pointX) - Math.sin(angle) * (pointY);
        var y = Math.sin(angle) * (pointX) + Math.cos(angle) * (pointY);
        return [x,y]
    }


    // utils
    document.onmousedown = printCoordsAndRGB;

    function printCoordsAndRGB(e){
        var x = e.pageX;
        var y = e.pageY;
        var coords = "Mouse x = "+x+", mouse y = "+y;
        console.log(coords);
        if (pixels){
            console.log(getPixelRGB(pixels, x,y, imageWidth,imageHeight));
        }

        Array.prototype.minElement = function(){
            var n = this.length;
            var minElement = this[0];
            for (var i = 0; i< n; i++){
                if (this[i]<= minElement){
                    minElement = this[i];
                }
            }
            return minElement;
        }

        Array.prototype.maxElement = function(){
            var n = this.length;
            var maxElement = this[0];
            for (var i = 0; i< n; i++){
                if (this[i]>= maxElement){
                    maxElement = this[i];
                }
            }
            return maxElement;
        }

    }
</script>
</body>
</html>    