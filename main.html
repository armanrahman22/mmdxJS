<!DOCTYPE HTML>
<html>
<head>
    <!-- Stylesheets -->
    <link rel="stylesheet" href="stylesheets/style.css">
    <link rel="stylesheet" href="resources/bootstrap.min.css">
    <link rel="stylsesheet" href="resources/bootstrap-theme.min.css">

    
    <!-- External resources and libraries -->
    <script type="text/javascript" src="resources/tracking.js"></script>
    <script type="text/javascript" src="resources/jquery.js"></script>
    <script type="text/javascript" src="resources/cornerdetect.js"></script>
    <script type="text/javascript" src="resources/Chart.js" charset="utf-8"></script>
    <script type="text/javascript" src="resources/bootstrap.min.js"></script>

    <!-- Functions to get test images in base 64-->
    <script type="text/javascript" src="test_images/initial_images.js"></script>
    <script type="text/javascript" src="test_images/test_images_rotated.js"></script>

    <!-- Own methods and helpers -->
    <script type="text/javascript" src="javascripts/utils.js"></script>
    <script type="text/javascript" src="javascripts/helpers.js"></script>
    <script type="text/javascript" src="javascripts/data_structures.js"></script>

    <!-- Google API for Geolocation-->
    <script src="https://maps.googleapis.com/maps/api/js?v=3.exp&signed_in=true"></script>


    

</head>
<body onload="DisplayRandomMap()">
<div class="container-fluid">
    <div class="row">
        <div class="canvas-container">
            <canvas id="canvas" class="row"></canvas>
            <p id="runtimeAnalysis"></p>
            <p id="mousePos"></p>
        </div>
        <div id="controls">
            
            <div class="btn-group" role="group">
                <button type="button" class="btn btn-default" onclick = "getRuntime(detect)"> Detect rectange </button>
                <button type="button" class="btn btn-default" onclick = "getRuntime(crop)"> Crop </button>
                <button type="button" class="btn btn-default" onclick = "getRuntime(rotate)"> Rotate </button>
                <button type="button" class="btn btn-default" onclick = "getRuntime(removeMarkers)"> Remove markers </button>
                <button type="button" class="btn btn-default" onclick = "getRuntime(getBlackBoxes)"> Find Black Boxes </button>
                <button type="button" class="btn btn-default" onclick = "getRuntime(LocateMe)"> Find Location </button>
                <button type="button" class="btn btn-default" onclick = "getRuntime(processAllLanes)">Process Lanes</button>
            </div>
        </div>
    </div>
    <div id="map-canvas" class="row"></div>
</div>
<div id="graph-container">
    <h3 id="chartTitle"></h3>
    <canvas id="graph" width="900" height="600"></canvas>
    <p>Graph Lane:</p><input type="number" id="laneNo" name="laneNo" value="0" min="0" oninput="input()">
</div>

<script>
    
//********************************** GEOLOCATION SETUP **********************************
    var mapOptions = {
        zoom: 2
      };
    var map = new google.maps.Map(document.getElementById('map-canvas'), mapOptions);
    var DisplayRandomMap = function(){
        var options = {
            map: map,
            position: new google.maps.LatLng(60, 105),
            content: "Map Initialized"
          };
        var infowindow = new google.maps.InfoWindow(options);
        map.setCenter(options.position);
    };
//********************************** END GEOLOCATION SETUP **********************************

//********************************** CANVAS SETUP **********************************

    var canvas = document.getElementById('canvas');
    var context = canvas.getContext('2d');
    var imageObj = new Image();
    var imageHeight, imageWidth;
    var imageData, pixels;

    //variables for the tracker.js
    var tracked_rect;
    var markerRectangle;

    //Test images in base64
    var mmdx_image_normal = getTestImageNormal();
    var mmdx_image_tilted_right = getTestImageRotatedRight();
    var mmdx_image_tilted_left = getTestImageRotatedLeft();
    var mmdx_image_tilted_left2 = getTestImageRotatedLeft2();


    // USED IN ANDROID

    // function loadImage(image_base64){
    //     imageObj = new Image();
    //     mmdx_image_app = image_base64;
    //     imageObj.src = image_base64;
    //     //console.log("Image from android");
    //     //console.log(image_base64.substring(0, 50));
    //     imageObj.onload = function() {
    //         imageHeight = imageObj.height;
    //         imageWidth = imageObj.width;
    //         canvas.height = imageHeight;
    //         canvas.width = imageWidth;
    //         context.drawImage(imageObj,0, 0);
    //     }
    // }


//************ COMMENT OUT INSIDE ANDROID ***************

    //Set test image
    //var mmdx_image = mmdx_image_normal;
    var mmdx_image = getImageRotated10();

    imageObj.src = mmdx_image_tilted_left;
    imageObj.crossOrigin = "anonymous"; //just in case


    //draw image to canvas
    imageObj.onload = function() {
        imageHeight = imageObj.height;
        imageWidth = imageObj.width;
        canvas.height = imageHeight;
        canvas.width = imageWidth;
        context.drawImage(imageObj,0, 0);
    };
    function loadImage(image_base64){
        imageObj.src = image_base64
    }
//******** END COMMENT OUT INSIDE ANDROID ***************


    //array that has the positional data of the lanes to be processed
    var markerBoxes=[];

    //the array of signal objects of the processed lanes
    var laneData=[];

//*****************************************************************************************************
//*****************************************************************************************************
//*********************************** YOU CAN COPY CODE AS FROM HERE INTO THE INNER ONE****************
//*****************************************************************************************************
//*****************************************************************************************************


    //Register color tracking.js uses to identify markers
    tracking.ColorTracker.registerColor('marker', function(r, g, b) {
        return isRed({r:r,g:g,b:b});
            
    });
//********************************** END CANVAS SETUP **********************************


//********************************** RECOGNITION: MARKER DETECTION *********************
    
    /**
    DETECTION:
    Uses tracking.js to find markers (color details are specified above)
    Finds a rectangle around a detected object
         (tracker returns "rect" object {x: value, y:value, height:value, width:value, color:value})
    If not rotated, will draw the abovementioned rectange and use its corners
    If rotated, find the intersection of the actual rectange with the abovemention rectangle
    and assigns corners correctly
    */
    var detect = function(){

        imageData = context.getImageData(0,0,imageWidth, imageHeight);
        pixels = imageData.data;
        console.log("Start Detecting");


        var tracker = new tracking.ColorTracker(['marker']);
        tracker.on('track', function(event) {
            event.data.forEach(function(rect) {
                tracked_rect = rect;
                var x = rect.x;
                var y = rect.y;
                var w = rect.width;
                var h = rect.height;
                //corners might change
                var corners = [new Point(x,y),new Point(x+w, y+h), new Point(x+w,y), new Point(x, y+h)];

                var rotated = checkIfRotated();
                markerRectangle = new Rectangle(corners, rotated);

                if (markerRectangle.isRotated()){
                    findCorners();
                }
                drawRectangle(markerRectangle.getCorners());
            });
        });
        tracking.track('#canvas', tracker); //start tracking

    };

    
    /**
    Additional detection if the image is rotated and corners form tracking.js 
    might not be exact
    */
    var detectCorners = function(){
        // parameters for Harris corner detection
        // blockSize: Neighborhood size (3×3 or 5×5)
        // k: Harris detector free parameter (recommends 0.04 ~ 0.15)
        // qualityLevel: Parameter characterizing the minimal accepted quality of image corners
        var params = {blockSize: 5, k: 0.04, qualityLevel: 0.01 };
        // img: ImageData object
        // returns Array of detected corners
        var img = context.getImageData(0,0,imageWidth, imageHeight);
        pixels = img.data;
        var corners = CornerDetector.detect(img, CornerDetector.HARRIS, params);//all corners
        var nonzero = [];
        for (var i = 0; i< corners.length; i++){
            if (corners[i]!=0){
                nonzero.push(i);
            }
        }
        //filter by color
        var redCorners = [];
        for (var j=0; j< nonzero.length; j++){
            var coords = getCoordsFromPixelOffset(nonzero[j], imageWidth, imageHeight);
            if (isAreaRed(coords[0],coords[1], 2, pixels, imageWidth, imageHeight)){
                redCorners.push(new Point(coords[0], coords[1]));
                //visually show detected points
                context.beginPath();
                context.arc(coords[0], coords[1], 5, 0, 2 * Math.PI);
                context.lineWidth = 2;
                context.strokeStyle = 'yellow';
                context.stroke();
            }
        }

        return redCorners;
    };
    
    /*
    Moves along the detected rectangle, if the majority of the points are red, assumes
    tracker found a correct rectangle
    */
    var checkIfRotated = function(){
        var threshhold = .1;  //NEED TO ADJUST/TEST
        var x = tracked_rect.x;
        var y = tracked_rect.y;
        var w = tracked_rect.width;
        var h = tracked_rect.height;
        var numPoints = 2*(w+h);
        var countRed = 0;
        //move along the top edge
        for (var i = 0; i<w; i++){
            var px = getPixelRGB(pixels, x+i, y, imageWidth, imageWidth);
            if (isRed(px)){
                countRed++
            }
        }
        //bottom edge
        for (var i = 0; i<w; i++){
            var px = getPixelRGB(pixels, x+i, y+h, imageWidth, imageWidth);
            if (isRed(px)){
                countRed++
            }
        }

        //left edge
        for (var i = 0; i<h; i++){
            var px = getPixelRGB(pixels, x, y+i, imageWidth, imageWidth);
            if (isRed(px)){
                countRed++
            }
        }
        //right edge
        for (var i = 0; i<h; i++){
            var px = getPixelRGB(pixels, x+w, y+i, imageWidth, imageWidth);
            if (isRed(px)){
                countRed++
            }
        }
        if (countRed/numPoints < threshhold){
            return true;
        }
        else{
            return false;
        }
    };

    /*
    If oldCheckIfRotated returns true, finds the corners of the rotated markers
    */
    var findCorners = function(){
        var x = tracked_rect.x;
        var y = tracked_rect.y;
        var w = tracked_rect.width;
        var h = tracked_rect.height;
        var c1, c2, c3, c4; //corners

        //check possible combinations:

        var inc = -1;

        // walk along the top rect edge (and lines right below), find the first points where
        // the detected rectange intersects the marker (first red point)
        while (!c1){
            inc++;
            for (var i = 0; i < w; i++){
                var px = getPixelRGB(pixels, x+i, y+inc, imageWidth, imageWidth);
                if (isRed(px)){
                    c1 = new Point(x+i, y);
                    console.log("C1");
                    console.log(c1);
                    break;
                }
            }
        }
        //same for the bottom rect egde
        inc = -1;
        while (!c2){
            inc++;
            for (var i = 0; i < w; i++){
                var px = getPixelRGB(pixels, x+i, y+h-inc, imageWidth, imageWidth);
                if (isRed(px)){
                    c2 = new Point(x+i, y+h);
                    console.log("C2");
                    console.log(c2);
                    break;
                }
            }
        }
        // left rect edge
        inc = -1;
        while (!c3){
            inc++;
            //leftline
            for (var i = 0; i < h; i++){
                var px = getPixelRGB(pixels, x+inc, y+i, imageWidth, imageWidth);
                if (isRed(px)){
                    c3 = new Point(x, y+i);
                    console.log("C3");
                    console.log(c3);
                    break;
                }
            }
        }
        // right rect edge
        while (!c4){
            inc++;
            for (var i = 0; i < h; i++){
                var px = getPixelRGB(pixels, x+w-inc, y+i, imageWidth, imageWidth);
                if (isRed(px)){
                    c4 = new Point(x+w, y+i);
                    console.log("C4");
                    console.log(c4);
                    break;
                }
            }
        }
        //adjust corners according to the Harris operator
        var cornersHarris = detectCorners();
        var corners = [c1,c2,c3,c4];
        for (var i = 0; i< 4; i++){
            var closest = findClosest(corners[i], cornersHarris, imageWidth*0.02);
            if (closest){
                corners[i] = closest;
            }

        }
        markerRectangle.setCorners(corners);

    };

    var drawRectangle = function(points){
        var c1 = points[0];
        var c2 = points[1];
        var c3 = points[2];
        var c4 = points[3];
        console.log("drawCorners:",c1,c2,c3,c4 );
        context.beginPath();
        context.beginPath();
        context.moveTo(c1.x,c1.y);
        context.lineTo(c3.x,c3.y);
        context.lineTo(c2.x,c2.y);
        context.lineTo(c4.x,c4.y);
        //context.lineTo(c1.x,c1.y);
        context.closePath();
        context.stroke();
    };
//********************************** END RECOGNITION: MARKER DETECTION *********************

//********************************** RECOGNITION: ROTATION *********************************
    /*
    Rotates the image based on the angle between the top line of the rect (from tracker)
    and new rotated rect (whose corners are found in findCorners())
    */
    var rotate = function (){
        if (!markerRectangle.isRotated()){
            alert("no need to rotate");
            return;
        }
        var c1 = markerRectangle.getCorners()[0];
        var c2 = markerRectangle.getCorners()[1];
        var c3 = markerRectangle.getCorners()[2];
        var c4 = markerRectangle.getCorners()[3];

        //save image data so we can modify canvas
        var imageURL = canvas.toDataURL();
        var image = new Image();
        image.src = imageURL;

        var angle = markerRectangle.findAngleOfRotation();

        //find the center to rotate about
        var center = new Point(Math.round(tracked_rect.x+tracked_rect.width/2), Math.round(tracked_rect.y+tracked_rect.height/2));
        context.translate(1*center.x, 1*center.y);

        
        context.save();
        context.rotate(angle.radians); //canvas rotate clockwise
        context.translate(-1*center.x, -1*center.y);
        context.drawImage(image,0, 0);
        context.restore();
        // translate back to 0,0 coordinates
        context.translate(-1*center.x, -1*center.y);
        rotated = false;

    };
//********************************** END RECOGNITION: ROTATION *********************

//********************************** RECOGNITION: CROP *********************

    /*
    Crops the image by its markers (either rect from tracker or adjusted corners)
    Assumes corners are known
    */
    var crop = function(){
        var c1 = markerRectangle.getCorners()[0];
        var c2 = markerRectangle.getCorners()[1];
        var c3 = markerRectangle.getCorners()[2];
        var c4 = markerRectangle.getCorners()[3];

        // Create a canvas that we will use as a mask
        var maskCanvas = document.createElement('canvas');
        // Ensure same dimensions
        maskCanvas.width = canvas.width;
        maskCanvas.height = canvas.height;
        var maskCtx = maskCanvas.getContext('2d');
        // This color is the one of the filled shape
        maskCtx.fillStyle = "white";
        // Fill the mask
        maskCtx.fillRect(0, 0, maskCanvas.width, maskCanvas.height);
        // Set xor operation
        maskCtx.globalCompositeOperation = 'xor';
        // Draw the shape you want to take out
        maskCtx.beginPath();
        maskCtx.moveTo(c1.x,c1.y);
        maskCtx.lineTo(c3.x,c3.y);
        maskCtx.lineTo(c2.x,c2.y);
        maskCtx.lineTo(c4.x,c4.y);
        maskCtx.lineTo(c1.x,c1.y);
        maskCtx.closePath();
        maskCtx.fill();
        context.drawImage(maskCanvas, 0, 0);
        context.save();

    };
//********************************** END RECOGNITION: REMOVE MARKERS *********************
    /*
    Removes red markers, assumes the image is properly oriented
    */
    var removeMarkers = function(){
        var padding = 10;
        console.log("removing");
        var leftEdge, rightEdge, upperEdge, lowerEdge;
        var w = canvas.width;
        var h = canvas.height;
        imageData = context.getImageData(0,0,w, h);
        pixels = imageData.data;
        var y = 0;
        //look for beginning of the top edge
        while(!(isRed(getPixelRGB(pixels, Math.round(w/2),y, w, h)))){
            y++;
        }
        //end of the top edge
        while (isRed(getPixelRGB(pixels, Math.round(w/2),y, w, h))) {
            y++;
        }
        upperEdge = y-1 + padding;

        //look for beginning of the bottom edge
        y = h;
        while(!(isRed(getPixelRGB(pixels, Math.round(w/2),y, w, h)))){
            y--;
        }
        //end of the bottom edge
        while (isRed(getPixelRGB(pixels, Math.round(w/2),y, w, h))) {
            y--;
        }
        lowerEdge = y+1 - padding;

        //look for beginning of the left edge
        var x = 0;
        while(!(isRed(getPixelRGB(pixels, x, Math.round(h/2), w, h)))){
            x++;
        }
        //end of the right edge
        while (isRed(getPixelRGB(pixels, x,Math.round(h/2), w, h))) {
            x++;
        }
        leftEdge = x+1 + padding;

        var x = w;
        while(!(isRed(getPixelRGB(pixels, x, Math.round(h/2), w, h)))){
            x--;
        }
        //end of the right edge
        while (isRed(getPixelRGB(pixels, x,Math.round(h/2), w, h))) {
            x--;
        }
        rightEdge = x-1 - padding;
        console.log(leftEdge, rightEdge, upperEdge, lowerEdge);
        context.drawImage(canvas, leftEdge, upperEdge, rightEdge - leftEdge, lowerEdge - upperEdge, 0, 0, w, h);


    }

//****************************** END RECOGNITION: REMOVE MARKERS *********************    

//****************************** RECOGNITION: BLACK BOX DETECTION ********************
    function getBlackBoxes(){
        //This is just for optimization might get rid of it if it causes problems
        var searchWidth = canvas.width;
        var searchHeight = canvas.height * .20;
        //coordinates of the black boxes
        var rawBoxData = [];
        var boxArray = [];
        var pixelRow = context.getImageData(0, 0, searchWidth, 1);
        var data = pixelRow.data;

        /**
         * Finds the vertical middle of the row of black boxes. We use this row to search because the tops and bottoms of the boxes aren't perfectly aligned.
         * @returns {number}
         */
        function getMiddleYOfBoxes() {
            var startColumn = 0;
            var horizontalMiddleOfBox = 0;
            while (!foundFirstBoxEdge(data) && horizontalMiddleOfBox < searchHeight) {
                pixelRow = context.getImageData(startColumn, horizontalMiddleOfBox, searchWidth, 1);
                data = pixelRow.data;
                horizontalMiddleOfBox++;
            }
            horizontalMiddleOfBox += canvas.height * .04;
            return horizontalMiddleOfBox;
        }

        /**
         * Fills the box arrays with their dimensions
         */
    function getBoxEdges(){
            var startColumn = 0;
            var horizontalMiddleOfBox = getMiddleYOfBoxes();
            var pixelRowMiddle = context.getImageData(startColumn, horizontalMiddleOfBox, searchWidth, 1);
            var midData = pixelRowMiddle.data;
            findBlackBoxEdgesFromMiddle(startColumn,rawBoxData,midData);
            for(var boxData = 0; boxData < rawBoxData.length; boxData += 2){
                boxArray.push([rawBoxData[boxData],rawBoxData[boxData+1]])
            }
            for(var box = 0; box<boxArray.length; box++){
                getHeights(boxArray[box]);
                removeExtraYCoords(boxArray[box]);
                drawLanes(boxArray[box]);
            }
            markerBoxes=boxArray;
        }
        getBoxEdges();
    }


//****************************** END RECOGNITION: BLACK BOX DETECTION ****************

//****************************** ANALYSIS: LANE PROCESSING ***************************

//Parameters:
    //start_x: lane left line x
    //start_y: top marker box bottom y
    //end_x: lane right line x
    //end_y: bottom marker box top y
    //sampling rate: floating point number between (0.0,1.0) specifying what percentage
    //of the lane will be processed
    //Return value: 
    //signal object of one lane with the following properties
    //  rgbVector: rgb average of each sampled band
    //  start_x, end_x, start_y, end_y
    //  strip_length, strip_width
    //  samplingRate, numberOfSamples
    var processLane=function (start_x,end_x,start_y,end_y,samplingRate){
            context.fillStyle="green";
            pixels=context.getImageData(0,0,imageWidth,imageHeight).data;

            var signal={};
            signal.samplingRate=samplingRate;
            signal.start_x=start_x;
            signal.start_y=start_y;
            signal.end_x=end_x;
            signal.end_y=end_y;

            signal.strip_length=Math.abs(end_y-start_y);
            signal.strip_width=Math.abs(end_x-start_x);
            signal.numberOfSamples=Math.ceil(signal.strip_length*samplingRate);

            var increment=Math.floor(signal.strip_length/(signal.numberOfSamples-1));


            var rgbVector=[];
            var hslVector=[];
            var index=0;

            
            for (var i=start_y; i < end_y; i+=increment){
                var test_r=0;
                var test_g=0;
                var test_b=0;


                //averaging rgb values along each band   
                for(var j=start_x; j < end_x; j++){
                    rgb=getPixelRGB(pixels,j,i,imageWidth,imageHeight);
                    test_r+=rgb.r;
                    test_g+=rgb.g;
                    test_b+=rgb.b;
                }
                test_r/=signal.strip_width;
                test_g/=signal.strip_width;
                test_b/=signal.strip_width;
                rgbVector[index]={"r":test_r,"g":test_g,"b":test_b};
                hslVector[index]=rgbToHsl(test_r,test_g,test_b);
                index++;

                context.fillRect(start_x,i,signal.strip_width,1);
            }

            signal.rgbVector=rgbVector;
            signal.hslVector=hslVector;

            return signal;
    }

    function processAllLanes(){
        var i=0;
        var samplingRate=0.4;
        for(var i in markerBoxes){
            var test=markerBoxes[i];
            laneData[i]=processLane(test[0],test[1],test[2],test[3],samplingRate);
            i++;
        }

    }; 

//************************** END ANALYSIS: LANE PROCESSING ****************************

//************************** GEOLOCATION ********************************************** 

    //handling geolocation here
    //current version only works on the click of a button, therefore, we have a button up there "Locate Me"
    //Later: pass in diagnosis as argument to LocateMe <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<IMPORTANT
//handling geolocation here
    //current version only works on the click of a button, therefore, we have a button up there "Locate Me"
    //Later: pass in diagnosis as argument to LocateMe <<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<<IMPORTANT
    function LocateMe() { // works on LG but not on OPO
        console.log("Running Locate Me!");
      // Try HTML5 geolocation
      if(navigator.geolocation) {
        console.log("NAVIGATOR OK");
        //console.log(navigator.geolocation.getCurrentPosition);
        navigator.geolocation.getCurrentPosition(function(position) {
            console.log("POS Running");
            var pos = new google.maps.LatLng(position.coords.latitude,
                                           position.coords.longitude);
            console.log("INFO-WINDOW Running");
            var infowindow = new google.maps.InfoWindow({
                map: map,
                position: pos,
                content: 'Location found using HTML5.'
            });
            console.log("myLOCATION Running");
            var mylocation = {lat: position.coords.latitude, lng:position.coords.longitude};
            // call to function to send to DB
            var Results = mylocation;
            Results.diagnosis = "Ebola";
            sendDataToDB(Results);
            //END this call here
            console.log("This is my Location");
            console.log(mylocation.lat);
            console.log(mylocation.lng);
            map.setCenter(pos);
            }, function() {
                console.log("HandleGeolocFailure within navigator Running");
                handleGeolocationFailure(true);
                },
            { timeout:60000,
              enableHighAccuracy:false
          });
        } else {
            console.log("NAVIGATOR NOT OK");
            // Browser doesn't support Geolocation
            handleGeolocationFailure(false);
        }
    }
    //this function handles the case when geolocation cannot be found, then it centers the map component at a random location
    function handleGeolocationFailure(errorFlag) {
        console.log("Running handleGeolocationFailure");
      if (errorFlag) {
        console.log("Error: The Geolocation service failed");
        var content = 'Error: The Geolocation service failed.';
      } else {
        console.log("Error: Browser does not support geolocation");
        var content = 'Error: Your browser doesn\'t support geolocation.';
      }
      var options = {
        map: map,
        position: new google.maps.LatLng(100, 105),
        content: content
      };
      var infowindow = new google.maps.InfoWindow(options);
      map.setCenter(options.position);
  }

//************************** END GEOLOCATION ******************************************

//************************** SEND DATA TO SERVER ************************************** 

    // Flow works as follows: detect Rectangle, Rotate, Crop, removeMarkers, FindBlackBoxes
    //                        Analyse/ Diagnose (To be implemented), Find Location
    //                        (Find Location then calls sendDataToDB);
    // Automatically do image processing, Diagnosis and location finding when called
    // this will be used to post stuff to the DB as well
    function sendDataToDB(results){
        //results contains: lng, lat, diagnosis
        console.log("calling the diagnosis function");
        console.log(results.lat);
        console.log(results.lng);
        console.log(results.diagnosis);

        var url = "http://localhost:5000/results?"; //lat=10.1&lng=10&diagnosis=Ebola;
        //sends dummy data, not yet connected to website
        //location.href = url+ "lat="+results.lat+"&lng="+results.lng+"&diagnosis="+results.diagnosis;
        console.log("calling Set Data");
        setData(JSON.stringify(results));

    }


    //testing sending stuff to native android
    var setData = function(data) {
            console.log("okay i got into the local SetData method");
            Android.setData(data);
            window.alert("Data sent to Native Android");
    }

//************************** END SEND DATA TO SERVER **********************************

//************************** GRAPH RESULTS ********************************************

    //graphs the rgb values for the given laneIndex
    function graph(laneIndex){
        var lane=laneData[laneIndex];
        var rgb=lane.rgbVector;
        console.log("strip_length"+lane.strip_length);
        console.log("samplingRate"+lane.samplingRate);
        console.log("#samples: "+lane.numberOfSamples); //sometimes off by 1
        console.log("rgbVector:"+rgb.length);
        var xLabels=range(rgb.length);
        var ctx = document.getElementById("graph").getContext("2d");

        var r_data=[];
        var g_data=[];
        var b_data=[];

        for (var colors in rgb){
            r_data[colors]=rgb[colors].r;
            g_data[colors]=rgb[colors].g;
            b_data[colors]=rgb[colors].b;
        }
        //console.log(r_data);
        var data = {
            labels: xLabels,
            datasets: [
                {
                    label: "r values",
                    fillColor: "rgba(255,0,0,0.5)",
                    strokeColor: "rgba(255,0,0,0.8)",
                    highlightFill: "rgba(255,0,0,0.75)",
                    highlightStroke: "rgba(255,0,0,1)",
                    data: r_data
                },
                {
                    label: "g values",
                    fillColor: "rgba(0,255,0,0.5)",
                    strokeColor: "rgba(0,255,0,0.8)",
                    highlightFill: "rgba(0,255,0,0.75)",
                    highlightStroke: "rgba(0,255,0,1)",
                    data: g_data
                },
                {
                    label: "b values",
                    fillColor: "rgba(0,0,255,0.5)",
                    strokeColor: "rgba(0,0,255,0.8)",
                    highlightFill: "rgba(0,0,255,0.75)",
                    highlightStroke: "rgba(0,0,255,1)",
                    data: b_data
                }
            ]
        };
        $("#chartTitle").text("RGB values for each sampled band for lane#"+laneIndex);
        var chart=new Chart(ctx).Bar(data,Chart.defaults);
    };
    //input event for graph textbox
    function input(){
        var laneNumber=$("#laneNo").val();
        if (laneNumber>=0 || laneNumber<laneData.length){
            graph(laneNumber);
        } else{
            alert("Please enter a number between 0 and "+laneData.length);
        }
    };

//************************** END GRAPH RESULTS ****************************************

//************************** DEBUGGING TOOLS ******************************************
    function getMousePos(canvas, evt) {
        var rect = canvas.getBoundingClientRect();
        var mouseX = evt.clientX - rect.left;
        var mouseY = evt.clientY - rect.top;
        var p = context.getImageData(mouseX, mouseY, 1, 1).data;
        hsl = rgbToHsl(p[0],p[1],p[2]);
        return {
            x: mouseX,
            y: mouseY,
            r: p[0],
            g: p[1],
            b: p[2],
            h: hsl.h * 360,
            s: hsl.s,
            l: hsl.l
        };
    }

    canvas.addEventListener('mousemove', function(evt) {
        var mousePos = getMousePos(canvas, evt);
        var message = 'Mouse position: ' + mousePos.x + ', ' + mousePos.y +
                "  :  Color: " + mousePos.r+ ', ' +mousePos.g+ ', ' +mousePos.b+
                "  :  HSL: "+mousePos.h.toFixed(2)+ ', ' +mousePos.s.toFixed(2)+ ', ' +mousePos.l.toFixed(2);
        $("#mousePos").text(message);
    }, false);

    var troubleShoot=function(err){
        Android.troubleShoot(err);
    }
//********************** END DEBUGGING TOOLS ******************************************

</script>
</body>
</html>
